import React, { useState, useEffect, useRef } from 'react';
import { View, Text, TouchableOpacity, Platform } from 'react-native';
import { StatusBar } from 'expo-status-bar';
import { StyleSheet } from "react-native";
import { Ionicons } from '@expo/vector-icons';
import MapView, { PROVIDER_GOOGLE, Marker } from 'react-native-maps';
import MapViewDirections from 'react-native-maps-directions';
import * as Location from 'expo-location';
import driverSocketService from '../../services/driverSocketService';
import { COLORS, SPACING, SHADOWS } from '../../constants/theme';
import config from '../../constants/config';

export default function TechnicianNavigationScreen({ route, navigation }) {
    const { rideId, destination } = route.params;
    const mapRef = useRef(null);

    const [currentLocation, setCurrentLocation] = useState(null);
    const [heading, setHeading] = useState(0);
    const [speed, setSpeed] = useState(0);
    const [distance, setDistance] = useState(null);
    const [duration, setDuration] = useState(null);
    const [isNavigating, setIsNavigating] = useState(false);

    const watchSubscriptionRef = useRef(null);
    const lastSentLocationRef = useRef(null);
    const hasInitialFitRef = useRef(false); // Prevent multiple fits

    useEffect(() => {
        if (!rideId) return;

        console.log('ðŸš— Technician Navigation - Ride:', rideId);
        connectSocket();
        startTracking();
        fetchRoute();

        return () => {
            stopTracking();
            console.log('Keeping socket alive');
        };
    }, [rideId]);

    const connectSocket = () => {
        driverSocketService.connect(rideId, (status) => {
            if (status === 'connected') {
                setTimeout(() => {
                    const socket = driverSocketService.getSocket();
                    if (socket?.connected) {
                        socket.emit('driver:join', { rideId });
                        console.log('âœ… Driver joined ride room');
                    }
                }, 500);
            }
        });
    };

    const fetchRoute = async () => {
        try {
            const pos = await Location.getCurrentPositionAsync({ accuracy: Location.Accuracy.High });
            const orig = `${pos.coords.latitude},${pos.coords.longitude}`;
            const dest = `${destination.lat || destination.latitude},${destination.lng || destination.longitude}`;

            const url = `https://maps.googleapis.com/maps/api/directions/json?origin=${orig}&destination=${dest}&mode=driving&key=${config.GOOGLE_MAPS_API_KEY}`;
            const response = await fetch(url);
            const data = await response.json();

            if (data.routes?.[0]?.legs?.[0]) {
                const leg = data.routes[0].legs[0];
                setDistance(leg.distance.value / 1000);
                setDuration(leg.duration.value / 60);
                console.log('ðŸ“ Route:', leg.distance.text, '-', leg.duration.text);
            }
        } catch (error) {
            console.error('Route error:', error);
        }
    };

    const startTracking = async () => {
        try {
            console.log('ðŸš€ [TRACKING] Requesting permission...');
            const { status } = await Location.requestForegroundPermissionsAsync();
            if (status !== 'granted') {
                console.error('âŒ Permission DENIED');
                return;
            }

            console.log('âœ… Getting initial location...');
            const loc = await Location.getCurrentPositionAsync({ accuracy: Location.Accuracy.High, maximumAge: 0, timeout: 15000 });
            const initial = { latitude: loc.coords.latitude, longitude: loc.coords.longitude };

            setCurrentLocation(initial);
            setHeading(loc.coords.heading || 0);
            setSpeed(loc.coords.speed || 0);
            lastSentLocationRef.current = initial;

            console.log('âœ… Initial:', initial.latitude.toFixed(6), initial.longitude.toFixed(6));

            // Start watching
            console.log('ðŸŽ¯ Starting GPS watch...');
            watchSubscriptionRef.current = await Location.watchPositionAsync(
                {
                    accuracy: Location.Accuracy.High,
                    timeInterval: 1000, // Every 1 second
                },
                (location) => {
                    console.log('ðŸ’š [WATCH] GPS UPDATE RECEIVED!');
                    handleLocationUpdate(location);
                }
            );

            console.log('âœ… GPS WATCH ACTIVE!');
            setIsNavigating(true);

        } catch (error) {
            console.error('âŒ [TRACKING ERROR]:', error.message);
            alert('GPS Error: ' + error.message);
        }
    };

    const stopTracking = () => {
        watchSubscriptionRef.current?.remove();
    };

    const getDistance = (lat1, lon1, lat2, lon2) => {
        const R = 6371000;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    };

    const handleLocationUpdate = (loc) => {
        const newLoc = { latitude: loc.coords.latitude, longitude: loc.coords.longitude };

        console.log('ðŸ”µ [GPS] New:', newLoc.latitude.toFixed(6), newLoc.longitude.toFixed(6), 'Speed:', (loc.coords.speed || 0).toFixed(1), 'm/s');

        // ALWAYS UPDATE UI - DO NOT SKIP THIS
        setCurrentLocation(newLoc);
        setHeading(loc.coords.heading || 0);
        setSpeed(loc.coords.speed || 0);
        console.log('ðŸŸ¢ [UI] State updated - marker should render');

        // Camera follow
        mapRef.current?.animateCamera({
            center: newLoc,
            heading: loc.coords.heading || 0,
            pitch: 60,
            zoom: 18,
        }, { duration: 1000 });

        // GPS Filter for SERVER transmission only (not UI)
        let sendToServer = true;
        // CRITICAL: Always send FIRST location update
        if (!lastSentLocationRef.current) {
            sendToServer = true;
            console.log('ðŸŸ¡ [FILTER] FIRST location - FORCE SEND to customer');
        } else {
            const dist = getDistance(
                lastSentLocationRef.current.latitude,
                lastSentLocationRef.current.longitude,
                newLoc.latitude,
                newLoc.longitude
            );
            sendToServer = dist >= 3;
            console.log('âšª [FILTER] Moved: ' + dist.toFixed(1) + ' m - ' + (sendToServer ? 'âœ… SENDING' : 'âŒ TOO SMALL'));
        }

        if (sendToServer) {
            const socket = driverSocketService.getSocket();
            if (socket?.connected) {
                driverSocketService.sendLocation({
                    lat: newLoc.latitude,
                    lng: newLoc.longitude,
                    bearing: loc.coords.heading || 0,
                    speed: loc.coords.speed || 0,
                    timestamp: Date.now()
                });
                lastSentLocationRef.current = newLoc;
                console.log('âœ… [SOCKET] Transmitted successfully');
            } else {
                console.error('âŒ [SOCKET] Not connected!');
            }
        }
    };
    const formatSpeed = (mps) => Math.round((mps || 0) * 3.6);
    const formatDistance = (km) => !km ? '--' : km < 1 ? `${Math.round(km * 1000)} m` : `${km.toFixed(1)} km`;
    const formatDuration = (mins) => !mins ? '--' : mins >= 60 ? `${Math.floor(mins / 60)}h ${Math.round(mins % 60)}m` : `${Math.round(mins)} min`;


    return (
        <View style={styles.container}>
            <StatusBar style="dark" />
            <MapView
                ref={mapRef}
                provider={PROVIDER_GOOGLE}
                style={styles.map}
                showsUserLocation={false}
                initialRegion={{
                    latitude: currentLocation?.latitude || 20.2961,
                    longitude: currentLocation?.longitude || 85.8245,
                    latitudeDelta: 0.01,
                    longitudeDelta: 0.01,
                }}
            >
                {currentLocation && (
                    <Marker coordinate={currentLocation} anchor={{ x: 0.5, y: 0.5 }}>
                        <View style={[styles.carMarker, { transform: [{ rotate: `${heading}deg` }] }]}>
                            <Ionicons name="navigate" size={32} color={COLORS.technicianPrimary} />
                        </View>
                    </Marker>
                )}
                {destination && (
                    <Marker coordinate={{ latitude: destination.lat || destination.latitude, longitude: destination.lng || destination.longitude }}>
                        <View style={styles.destMarker}>
                            <Ionicons name="location" size={28} color={COLORS.error} />
                        </View>
                    </Marker>
                )}
                {/* Route Path - Like Google Maps */}
                {currentLocation && destination && (
                    <MapViewDirections
                        key={rideId}
                        origin={currentLocation}
                        destination={{
                            latitude: destination.lat || destination.latitude,
                            longitude: destination.lng || destination.longitude
                        }}
                        apikey={config.GOOGLE_MAPS_API_KEY}
                        strokeWidth={5}
                        strokeColor={COLORS.technicianPrimary}
                        precision="high"
                        mode="DRIVING"
                        onReady={(result) => {
                            console.log("ðŸ—ºï¸ Route ready");
                            if (!hasInitialFitRef.current && mapRef.current) {
                                hasInitialFitRef.current = true;
                                mapRef.current.fitToCoordinates(result.coordinates, {
                                    edgePadding: { top: 100, right: 50, bottom: 300, left: 50 },
                                    animated: true
                                });
                            }
                        }}
                        onError={(error) => console.error("Route error:", error)}
                    />
                )}
            </MapView>

            <View style={styles.speedContainer}>
                <Text style={styles.speedValue}>{formatSpeed(speed)}</Text>
                <Text style={styles.speedLabel}>km/h</Text>
            </View>

            <View style={styles.etaCard}>
                <View style={styles.etaRow}>
                    <Ionicons name="time-outline" size={16} color={COLORS.technicianPrimary} />
                    <Text style={styles.etaValue}>{formatDuration(duration)}</Text>
                </View>
                <Text style={styles.etaLabel}>{formatDistance(distance)}</Text>
            </View>

            <View style={styles.bottomSheet}>
                <TouchableOpacity style={styles.actionBtn} onPress={() => mapRef.current?.animateCamera({ center: currentLocation, heading, pitch: 60, zoom: 18 })}>
                    <Ionicons name="locate" size={24} color={COLORS.technicianPrimary} />
                </TouchableOpacity>
                <TouchableOpacity style={styles.endBtn} onPress={() => navigation.goBack()}>
                    <Ionicons name="stop-circle" size={20} color={COLORS.white} />
                    <Text style={styles.endBtnText}>End Navigation</Text>
                </TouchableOpacity>
            </View>
        </View>
    );
}

const styles = StyleSheet.create({
    container: { flex: 1, backgroundColor: COLORS.black },
    map: { flex: 1 },
    carMarker: { width: 48, height: 48, backgroundColor: COLORS.white, borderRadius: 24, justifyContent: 'center', alignItems: 'center', ...SHADOWS.large, borderWidth: 3, borderColor: COLORS.technicianPrimary },
    destMarker: { backgroundColor: COLORS.white, padding: 8, borderRadius: 20, ...SHADOWS.medium },
    speedContainer: { position: 'absolute', top: Platform.OS === 'ios' ? 60 : 40, left: 20, backgroundColor: COLORS.white, borderRadius: 16, padding: SPACING.md, alignItems: 'center', minWidth: 80, ...SHADOWS.medium },
    speedValue: { fontSize: 32, fontWeight: '900', color: COLORS.technicianPrimary },
    speedLabel: { fontSize: 12, color: COLORS.grey, marginTop: 2 },
    etaCard: { position: 'absolute', top: Platform.OS === 'ios' ? 60 : 40, right: 20, backgroundColor: COLORS.white, borderRadius: 16, padding: SPACING.md, ...SHADOWS.medium },
    etaRow: { flexDirection: 'row', alignItems: 'center', gap: 6, marginBottom: 4 },
    etaValue: { fontSize: 18, fontWeight: 'bold', color: COLORS.technicianPrimary },
    etaLabel: { fontSize: 12, color: COLORS.grey },
    bottomSheet: { position: 'absolute', bottom: 0, left: 0, right: 0, backgroundColor: COLORS.white, borderTopLeftRadius: 30, borderTopRightRadius: 30, padding: SPACING.xl, flexDirection: 'row', gap: SPACING.md, ...SHADOWS.large },
    actionBtn: { width: 56, height: 56, borderRadius: 16, backgroundColor: COLORS.technicianBg, justifyContent: 'center', alignItems: 'center', borderWidth: 1, borderColor: COLORS.technicianAccent },
    endBtn: { flex: 1, height: 56, borderRadius: 16, backgroundColor: COLORS.error, flexDirection: 'row', justifyContent: 'center', alignItems: 'center', gap: 8, ...SHADOWS.medium },
    endBtnText: { fontSize: 16, fontWeight: 'bold', color: COLORS.white },
});